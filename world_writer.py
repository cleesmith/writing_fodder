# python -B world_writer.py --outline_file outline.txt --detailed
# pip install anthropic
# tested with: anthropic 0.49.0 circa March 2025
import anthropic
import os
import argparse
import re
import sys
import time
from datetime import datetime

parser = argparse.ArgumentParser(description='Extract and develop characters and world elements from a novel outline.')
parser.add_argument('--outline_file', type=str, required=True, help="Path to the outline file generated by outline_writer.py")
parser.add_argument('--request_timeout', type=int, default=600, help='Maximum timeout for output (default: 600 seconds)')
"""
request_timeout is for each chunk and not for the entire request time:
script                      API
  |                          |
  |------ Request ---------->|
  |                          |
  |<----- first chunk -------|  ← timeout applies here
  |                          |
  |<----- next chunk --------|  ← and here (timeout is reset for each chunk)
  |                          |
  |        ...etc...         |
"""
parser.add_argument('--thinking_budget', type=int, default=32000, help='Maximum tokens for AI thinking (default: 32000)')
parser.add_argument('--max_tokens', type=int, default=12000, help='Maximum tokens for output (default: 12000)')
parser.add_argument('--context_window', type=int, default=204648, help='Context window for Claude 3.7 Sonnet (default: 204648)')
parser.add_argument('--save_dir', type=str, default=".")
parser.add_argument('--example_world_file', type=str, default=None, help="Example world document for reference (optional)")
parser.add_argument('--lang', type=str, default="English", help='Language for writing (default: English)')
parser.add_argument('--character_count', type=int, default=None, help='Number of characters to develop (default: auto-detect)')
parser.add_argument('--detailed', action='store_true', help='Generate more detailed character and world profiles')
args = parser.parse_args()

def count_words(text):
    return len(re.sub(r'(\r\n|\r|\n)', ' ', text).split())

def extract_character_names(outline_text):
    """
    Extract potential character names from the outline using pattern matching.
    Returns a list of unique character names found in the outline.
    """
    # This is a simplified approach - more sophisticated NLP could be used
    potential_names = []
    
    # Common patterns for character names in narrative writing
    lines = outline_text.split('\n')
    for line in lines:
        # Look for capitalized words that might be names (excluding common words)
        words = re.findall(r'\b[A-Z][a-z]+\b', line)
        # Filter out common capitalized words that aren't usually names
        common_words = ['The', 'A', 'An', 'In', 'On', 'At', 'By', 'For', 'With', 
                        'About', 'Part', 'Chapter', 'I', 'II', 'III', 'IV', 'V', 
                        'VI', 'VII', 'VIII', 'IX', 'X', 'Outline']
        for word in words:
            if word not in common_words:
                potential_names.append(word)
    
    # Count occurrences of each potential name
    name_counts = {}
    for name in potential_names:
        name_counts[name] = name_counts.get(name, 0) + 1
    
    # Names that appear multiple times are more likely to be characters
    likely_names = [name for name, count in name_counts.items() if count >= 2]
    
    return likely_names

def extract_title_and_genre(outline_text):
    title = "Fiction"
    genre = "Fiction"
    
    lines = outline_text.split('\n')
    
    # Look for explicit tags
    for line in lines[:20]:  # Check first 20 lines for metadata
        line = line.strip()
        if line.upper().startswith("TITLE:"):
            title = line[6:].strip()  # Remove "TITLE:" and any leading/trailing spaces
        elif line.upper().startswith("GENRE:"):
            genre = line[6:].strip()  # Remove "GENRE:" and any leading/trailing spaces
    
    return title, genre

def extract_settings(outline_text):
    """
    Extract potential settings and locations from the outline.
    """
    settings = set()
    
    # Look for patterns that might indicate settings
    location_prefixes = ['at ', 'in ', 'to ', 'from ', 'through ']
    location_indicators = ['city', 'town', 'village', 'planet', 'station', 'building', 
                          'palace', 'castle', 'house', 'apartment', 'world', 'realm', 
                          'dimension', 'universe', 'country', 'continent', 'island']
    
    lines = outline_text.split('\n')
    for line in lines:
        # Check for location prefixes followed by capitalized words
        for prefix in location_prefixes:
            matches = re.findall(r'{}([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)'.format(prefix), line)
            settings.update(matches)
        
        # Check for location indicators preceded by "the" or "a" and possibly an adjective
        for indicator in location_indicators:
            matches = re.findall(r'(?:the|a|an)\s+(?:[a-z]+\s+)?{}'.format(indicator), line, re.IGNORECASE)
            settings.update(matches)
    
    return list(settings)

# Load example world file if provided
example_world_content = ""
if args.example_world_file:
    try:
        with open(args.example_world_file, 'r', encoding='utf-8') as file:
            example_world_content = file.read()
        print(f"Loaded example world document from: {args.example_world_file}")
    except FileNotFoundError:
        print(f"Note: Example world file not found: {args.example_world_file}")
        print("Continuing without example world document.")
    except Exception as e:
        print(f"Warning: Could not read example world file: {e}")
        print("Continuing without example world document.")

# Load the outline file
outline_content = ""
try:
    with open(args.outline_file, 'r', encoding='utf-8') as file:
        outline_content = file.read()
    print(f"Loaded outline from: {args.outline_file}")
except FileNotFoundError:
    print(f"Error: Outline file not found: {args.outline_file}")
    sys.exit(1)
except Exception as e:
    print(f"Error: Could not read outline file: {e}")
    sys.exit(1)

# Extract information from the outline
character_names = extract_character_names(outline_content)
title, genre = extract_title_and_genre(outline_content)
settings = extract_settings(outline_content)

# Determine number of characters to develop
num_characters = args.character_count if args.character_count is not None else min(len(character_names), 10)

if len(character_names) == 0:
    print("Warning: No character names were automatically detected.")
    print("Will generate generic character templates that you'll need to rename.")
    # Create some placeholder names
    character_names = ["Character" + str(i+1) for i in range(5)]
    num_characters = min(args.character_count if args.character_count is not None else 5, 5)
else:
    print(f"Detected {len(character_names)} potential character names: {', '.join(character_names)}")
    print(f"Will develop profiles for {num_characters} characters.")

# Create integrated world prompt with character section
world_prompt = f"""You are a skilled novelist, worldbuilder, and character developer helping to create a comprehensive world document in fluent, authentic {args.lang}.
This document will include both the world elements and detailed character profiles for a novel based on the outline below.

=== OUTLINE ===
{outline_content}
=== END OUTLINE ===

=== EXAMPLE WORLD FORMAT ===
{example_world_content}
=== END EXAMPLE WORLD FORMAT ===

Create a detailed world document with the following sections:

----------------------------------------------
WORLD: {title}
----------------------------------------------

1. SETTING OVERVIEW:
   - Time period and era
   - General geography and environment
   - Notable locations mentioned in the outline: {', '.join(settings) if settings else 'To be determined based on outline'}

2. SOCIAL STRUCTURE:
   - Government or ruling systems
   - Social classes or hierarchies
   - Cultural norms and values

3. HISTORY:
   - Major historical events that impact the story
   - Historical figures relevant to the plot
   - Timeline of important developments

4. TECHNOLOGY AND MAGIC:
   - Level of technological development
   - Technological systems or devices crucial to the plot
   - If applicable: magic systems, supernatural elements, or fantastic creatures

5. ECONOMY:
   - Economic systems
   - Resources and trade
   - Economic conflicts relevant to the story

6. THEMES AND SYMBOLS:
   - Recurring motifs and symbols
   - Philosophical or moral questions explored
   - Cultural or religious symbolism

7. RULES OF THE WORLD:
   - Laws (both legal and natural/supernatural)
   - Limitations and constraints
   - Unique aspects of how this world functions

8. CHARACTER PROFILES:
"""

# Add character profile instructions
world_prompt += f"""
   For each of the following characters, create a detailed profile:
   {', '.join(character_names[:num_characters])}

   Include for each character:

   a) CHARACTER NAME: [Full name]
   b) ROLE: [Protagonist, Antagonist, Supporting Character, etc.]
   c) AGE: [Age or age range]
   d) PHYSICAL DESCRIPTION: [Detailed physical appearance]
   e) BACKGROUND: [Personal history relevant to the story]
   f) PERSONALITY: [Core personality traits, strengths, and flaws]
   g) MOTIVATIONS: [What drives this character? What do they want?]
   h) CONFLICTS: [Internal struggles and external conflicts]
   i) RELATIONSHIPS: [Important relationships with other characters]
   j) ARC: [How this character changes throughout the story]
   k) NOTABLE QUOTES: [3-5 examples of how this character might speak]"""

if args.detailed:
    world_prompt += """
   l) SKILLS & ABILITIES: [Special skills, knowledge, or supernatural abilities]
   m) HABITS & QUIRKS: [Distinctive behaviors and mannerisms]
   n) SECRETS: [What this character is hiding]
   o) FEARS & WEAKNESSES: [What makes this character vulnerable]
   p) SYMBOLIC ELEMENTS: [Any symbolic elements associated with this character]
   q) NARRATIVE FUNCTION: [How this character serves the themes and plot]
"""

# Add formatting instructions
world_prompt += """
IMPORTANT FORMATTING INSTRUCTIONS:
- Use plain text formatting (no markdown)
- Separate each major section with a line of dashes (------)
- Separate each character profile with a line of dashes (------)
- Be consistent in formatting throughout the document
- Write in third person perspective
- Make the character profiles deep and psychologically nuanced
- Ensure character motivations are complex and realistic
- Create characters whose traits and backgrounds naturally arise from the world of the story
- Ensure the characters will create interesting dynamics and conflicts with each other
- Keep all details consistent with the outline
- Focus on elements that directly impact the characters and plot
- Provide enough detail to give the world depth while leaving room for creative development
- Ensure the world elements support and enhance the narrative
"""

# calculate a safe max_tokens value
estimated_input_tokens = int(len(world_prompt) // 5.5)
max_safe_tokens = max(5000, args.context_window - estimated_input_tokens - 1000)  # 1000 token buffer
max_tokens = int(min(args.max_tokens, max_safe_tokens))

# ensure max_tokens is always greater than thinking budget
if max_tokens <= args.thinking_budget:
    max_tokens = args.thinking_budget + args.max_tokens
    print(f"Adjusted max_tokens to {max_tokens} to exceed thinking budget of {args.thinking_budget} (room for thinking/writing)")

absolute_path = os.path.abspath(args.save_dir)

print(f"Max request timeout: {args.request_timeout} seconds")
print(f"Max retries: 0 (anthropic's default was 2)")
print(f"Max AI model context window: {args.context_window} tokens")
print(f"AI model thinking budget: {args.thinking_budget} tokens")
print(f"Generating world document (including characters) for novel: {title} ({genre})")
print(f"Setting max_tokens to: {max_tokens}")

client = anthropic.Anthropic(
    timeout=args.request_timeout,
    max_retries=0  # default is 2
)

# Count tokens for the prompt
prompt_token_count = 0
try:
    response = client.beta.messages.count_tokens(
        model="claude-3-7-sonnet-20250219",
        messages=[{"role": "user", "content": world_prompt}],
        thinking={
            "type": "enabled",
            "budget_tokens": args.thinking_budget
        },
        betas=["output-128k-2025-02-19"]
    )
    prompt_token_count = response.input_tokens
    print(f"Prompt tokens: {prompt_token_count}")
except Exception as e:
    print(f"Error counting tokens:\n{e}\n")

current_time = datetime.now().strftime("%I:%M:%S %p").lower().lstrip("0")
print(f"****************************************************************************")
print(f"*  Generating world document with character profiles...")
print(f"*  start time: {current_time}")
print(f"*  This process typically takes several minutes.")
print(f"*  ")
print(f"*  It's recommended to keep the Terminal or command line the sole 'focus'")
print(f"*  and to avoid browsing online or running other apps, as these API")
print(f"*  network connections are often flakey, like delicate echoes of whispers.")
print(f"*  ")
print(f"*  So breathe, remove eye glasses, stretch, relax, and be like water 🥋 🧘🏽‍♀️")
print(f"****************************************************************************")

world_response = ""
world_thinking = ""

start_time = time.time()

try:
    with client.beta.messages.stream(
        model="claude-3-7-sonnet-20250219",
        max_tokens=max_tokens,
        messages=[{"role": "user", "content": world_prompt}],
        thinking={
            "type": "enabled",
            "budget_tokens": args.thinking_budget
        },
        betas=["output-128k-2025-02-19"]
    ) as stream:
        for event in stream:
            if event.type == "content_block_delta":
                if event.delta.type == "thinking_delta":
                    world_thinking += event.delta.thinking
                elif event.delta.type == "text_delta":
                    world_response += event.delta.text
except Exception as e:
    print(f"Error generating world document:\n{e}\n")

elapsed = time.time() - start_time
minutes = int(elapsed // 60)
seconds = elapsed % 60

timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
world_filename = f"{args.save_dir}/world_{timestamp}.txt"
with open(world_filename, 'w', encoding='utf-8') as file:
    file.write(world_response)

word_count = count_words(world_response)

print(f"\nWorld document completed in: {minutes} minutes, {seconds:.2f} seconds.")
print(f"World document has {word_count} words.")
print(f"World document saved to: {world_filename}")

# Save thinking content if available
if world_thinking:
    thinking_filename = f"{args.save_dir}/world_thinking_{timestamp}.txt"
    with open(thinking_filename, 'w', encoding='utf-8') as file:
        file.write("=== PROMPT USED (EXCLUDING REFERENCE CONTENT) ===\n")
        file.write(f"Generating world document (including characters) for novel: {title} ({genre})\n")
        file.write("\n\n=== AI'S THINKING PROCESS ===\n\n")
        file.write(world_thinking)
        file.write("\n=== END AI'S THINKING PROCESS ===\n")
        file.write(f"\nStats:\n")
        file.write(f"Prompt tokens: {prompt_token_count}\n")
        file.write(f"Elapsed time: {minutes} minutes, {seconds:.2f} seconds\n")
        file.write(f"Word count: {word_count}\n")
    print(f"AI thinking process saved to: {thinking_filename}")

# Calculate token count of output
output_token_count = 0
try:
    response = client.beta.messages.count_tokens(
        model="claude-3-7-sonnet-20250219",
        messages=[{"role": "user", "content": world_response}],
        thinking={
            "type": "enabled",
            "budget_tokens": args.thinking_budget
        },
        betas=["output-128k-2025-02-19"]
    )
    output_token_count = response.input_tokens
    print(f"World document is {output_token_count} tokens")
except Exception as e:
    print(f"Error counting output tokens:\n{e}\n")

print(f"\nFiles saved to: {absolute_path}")
print(f"###\n")

# Clean up variables
world_prompt = None
world_response = None
world_thinking = None
client = None
